[{"content":"记录一次利用Github actions部署Hugo博客 安装和配置Hugo 根据hugo文档安装hugo和配置theme等\n部署  创建.github/workflows，新建文件hugo-deploy.yaml  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37  # hugo-deploy.yaml name: hugo publish on: push: branches: # 默认分支 - main jobs: build-deploy: runs-on: ubuntu-20.04 steps: - uses: actions/checkout@v2 with: submodules: true fetch-depth: 0 - name: Setup Hugo uses: peaceiris/actions-hugo@v2 with: extended: true hugo-version: \u0026#39;0.92.1\u0026#39; - name: Build run: hugo --minify - name: Deploy uses: peaceiris/actions-gh-pages@v2 env: ACTIONS_DEPLOY_KEY: ${{ secrets.ACTIONS_DEPLOY_KEY }} EXTERNAL_REPOSITORY: bankroft/bankroft.github.io PUBLISH_BRANCH: main PUBLISH_DIR: ./public with: emptyCommits: false commitMessage: ${{ github.event.head_commit.message }}    ssh-keygen等生成ssh key\n  在GitHub新建repository用来放hugo new site生成的内容，名称不能与\u0026lt;username\u0026gt;.github.io相同\n  在刚创建的的repository-\u0026gt;settings-\u0026gt;secrets-\u0026gt;actions-\u0026gt;new repository secret, name为ACTIONS_DEPLOY_KEY，Value填写生成的sshkey 私钥\n  在GitHub新建public repository，名称为\u0026lt;username\u0026gt;.github.io，用来存放github page的内容，也就是hugo生成的public里的内容\n  在第二个repository-\u0026gt;settings-\u0026gt;deploy keys-\u0026gt;add deploy key, key填生成的sshkey 公钥，title任意\n  将hugo new site生成内容push到第一个repository，然后到action里查看运行结果，如果有报错的话，action里查看log修改\n  ","date":"2022-02-18T15:00:10+08:00","permalink":"https://bankroft.github.io/posts/deploy_hugo/","title":"利用Github actions部署Hugo"},{"content":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95  def num2chinese(num: float or int): mapping = { \u0026#39;1\u0026#39;: \u0026#39;壹\u0026#39;, \u0026#39;2\u0026#39;: \u0026#39;贰\u0026#39;, \u0026#39;3\u0026#39;: \u0026#39;叁\u0026#39;, \u0026#39;4\u0026#39;: \u0026#39;肆\u0026#39;, \u0026#39;5\u0026#39;: \u0026#39;伍\u0026#39;, \u0026#39;6\u0026#39;: \u0026#39;陆\u0026#39;, \u0026#39;7\u0026#39;: \u0026#39;柒\u0026#39;, \u0026#39;8\u0026#39;: \u0026#39;捌\u0026#39;, \u0026#39;9\u0026#39;: \u0026#39;玖\u0026#39;, \u0026#39;0\u0026#39;: \u0026#39;零\u0026#39;, } if num == 0: return mapping[\u0026#39;0\u0026#39;] + \u0026#39;元整\u0026#39; base_unit = { 0: \u0026#39;\u0026#39;, 1: \u0026#39;拾\u0026#39;, 2: \u0026#39;佰\u0026#39;, 3: \u0026#39;仟\u0026#39;, } unit_integers = { -1: \u0026#39;\u0026#39;, 0: \u0026#39;万\u0026#39;, 1: \u0026#39;億\u0026#39;, 2: \u0026#39;兆\u0026#39; } unit_fractions = { \u0026#39;0\u0026#39;: \u0026#39;\u0026#39;, \u0026#39;1\u0026#39;: \u0026#39;角\u0026#39;, \u0026#39;2\u0026#39;: \u0026#39;分\u0026#39; } max_unit = max(list(unit_integers.keys())) + 1 result = \u0026#39;\u0026#39; # num = str(float(num)).split(\u0026#39;.\u0026#39;) num = str(num).split(\u0026#39;.\u0026#39;) if len(num) == 1 or not int(num[1]): result += unit_fractions[\u0026#39;0\u0026#39;] else: tmp_fraction = num[1] try: if int(tmp_fraction[1]): result += unit_fractions[\u0026#39;2\u0026#39;] result += mapping[tmp_fraction[1]] except IndexError: pass if int(tmp_fraction[0]): result += unit_fractions[\u0026#39;1\u0026#39;] result += mapping[tmp_fraction[0]] if not result: result += \u0026#39;整\u0026#39; result += \u0026#39;元\u0026#39; integers = num[0][::-1] unit_count = 0 tmp_unit = \u0026#39;\u0026#39; while True: tmp = integers[0:4] if len(tmp) == 0: break if int(tmp) == 0: if unit_count == max_unit: unit_count = 0 result += unit_integers[max_unit - 1] tmp_unit = unit_integers[unit_count] unit_count += 1 else: result += tmp_unit break integers = integers[4:] base_unit_count = -1 for i in range(0, len(integers), 4): v = integers[i: i + 4] continual_zero = True tmp = \u0026#39;\u0026#39; is_zero = True for x in range(len(v)): if v[x] == \u0026#39;0\u0026#39; and continual_zero: pass elif v[x] == \u0026#39;0\u0026#39; and not continual_zero: tmp += mapping[v[x]] continual_zero = True else: is_zero = False continual_zero = False tmp += base_unit[x] tmp += mapping[v[x]] if is_zero: pass else: result += (unit_integers[base_unit_count] + tmp) base_unit_count += 1 base_unit_count %= max_unit if result[-1] == \u0026#39;元\u0026#39;: return result[2::-1] return result[::-1]   ","date":"2019-08-29T10:56:37Z","permalink":"https://bankroft.github.io/posts/python-convert-number-to-chinese/","title":"python convert number to Chinese"},{"content":"code:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35  # coding:utf-8 from PIL import Image def img_to_txt(file_sou, file_dst): x = 120 # str_ = list(\u0026#39;$@B%8\u0026amp;amp;WM#*oahkbdpqwmZO0QLCJUYXzcvunxrjft/\\|()1{}[]?-_+~\u0026amp;lt;\u0026amp;gt;i!lI;:,\\\u0026#34;^`\\\u0026#39;. \u0026#39;) str_ = list(\u0026#39;@#+:,`.\u0026#39;) # str_ = list(\u0026#39;$@B%8\u0026amp;amp;WM#* \u0026#39;) # str_ = list(\u0026#39; .,\\\u0026#34;;*=+\u0026#39;) # 亮暗反转 # str_.reverse() img = Image.open(file_sou).convert(\u0026#39;L\u0026#39;) img = img.resize((x, img.size[1] // ((img.size[0] // x)))) size = img.size dst = \u0026#39;\u0026#39; for y in range(size[1]): for x in range(size[0]): tmp = img.getpixel((x, y)) dst += str_[(tmp*(len(str_) - 1)) // 255] * 2 dst += \u0026#39;\\n\u0026#39; with open(file_dst, \u0026#39;w\u0026#39;) as f: f.write(dst) if __name__ == \u0026#39;__main__\u0026#39;: import os import sys filename_s = sys.argv[1] filename_d = sys.argv[2] if os.path.exists(filename_s): img_to_txt(filename_s, filename_d) else: print(\u0026#34;file not found\u0026#34;)   ","date":"2019-08-01T12:49:11Z","permalink":"https://bankroft.github.io/posts/%E5%9B%BE%E7%89%87%E8%BD%AC%E5%AD%97%E7%AC%A6%E7%94%BB/","title":"图片转字符画"},{"content":"Nokia 5110 驱动 PCD8544\n引脚  rst:外部复位引脚 ce：显示屏使能引脚 dc：数据/命令引脚 din：串行数据输入端 clk：串行时钟输入端 vcc：电源引脚 bl： 亮度调节 gnd：接地  驱动代码-python 修改自(Adafruit) mode: BCM\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221  # coding:utf-8 import time import Adafruit_GPIO as GPIO import Adafruit_GPIO.SPI as SPI LCDWIDTH = 84 LCDHEIGHT = 48 ROWPIXELS = LCDHEIGHT//6 PCD8544_POWERDOWN = 0x04 PCD8544_ENTRYMODE = 0x02 PCD8544_EXTENDEDINSTRUCTION = 0x01 PCD8544_DISPLAYBLANK = 0x0 PCD8544_DISPLAYNORMAL = 0x4 PCD8544_DISPLAYALLON = 0x1 PCD8544_DISPLAYINVERTED = 0x5 PCD8544_FUNCTIONSET = 0x20 PCD8544_DISPLAYCONTROL = 0x08 PCD8544_SETYADDR = 0x40 PCD8544_SETXADDR = 0x80 PCD8544_SETTEMP = 0x04 PCD8544_SETBIAS = 0x10 PCD8544_SETVOP = 0x80 FONT = { \u0026#39; \u0026#39;: [0x00, 0x00, 0x00, 0x00, 0x00], \u0026#39;!\u0026#39;: [0x00, 0x00, 0x5f, 0x00, 0x00], \u0026#39;\u0026#34;\u0026#39;: [0x00, 0x07, 0x00, 0x07, 0x00], \u0026#39;#\u0026#39;: [0x14, 0x7f, 0x14, 0x7f, 0x14], \u0026#39;$\u0026#39;: [0x24, 0x2a, 0x7f, 0x2a, 0x12], \u0026#39;%\u0026#39;: [0x23, 0x13, 0x08, 0x64, 0x62], \u0026#39;\u0026amp;\u0026#39;: [0x36, 0x49, 0x55, 0x22, 0x50], \u0026#34;\u0026#39;\u0026#34;: [0x00, 0x05, 0x03, 0x00, 0x00], \u0026#39;(\u0026#39;: [0x00, 0x1c, 0x22, 0x41, 0x00], \u0026#39;)\u0026#39;: [0x00, 0x41, 0x22, 0x1c, 0x00], \u0026#39;*\u0026#39;: [0x14, 0x08, 0x3e, 0x08, 0x14], \u0026#39;+\u0026#39;: [0x08, 0x08, 0x3e, 0x08, 0x08], \u0026#39;,\u0026#39;: [0x00, 0x50, 0x30, 0x00, 0x00], \u0026#39;-\u0026#39;: [0x08, 0x08, 0x08, 0x08, 0x08], \u0026#39;.\u0026#39;: [0x00, 0x60, 0x60, 0x00, 0x00], \u0026#39;/\u0026#39;: [0x20, 0x10, 0x08, 0x04, 0x02], \u0026#39;0\u0026#39;: [0x3e, 0x51, 0x49, 0x45, 0x3e], \u0026#39;1\u0026#39;: [0x00, 0x42, 0x7f, 0x40, 0x00], \u0026#39;2\u0026#39;: [0x42, 0x61, 0x51, 0x49, 0x46], \u0026#39;3\u0026#39;: [0x21, 0x41, 0x45, 0x4b, 0x31], \u0026#39;4\u0026#39;: [0x18, 0x14, 0x12, 0x7f, 0x10], \u0026#39;5\u0026#39;: [0x27, 0x45, 0x45, 0x45, 0x39], \u0026#39;6\u0026#39;: [0x3c, 0x4a, 0x49, 0x49, 0x30], \u0026#39;7\u0026#39;: [0x01, 0x71, 0x09, 0x05, 0x03], \u0026#39;8\u0026#39;: [0x36, 0x49, 0x49, 0x49, 0x36], \u0026#39;9\u0026#39;: [0x06, 0x49, 0x49, 0x29, 0x1e], \u0026#39;:\u0026#39;: [0x00, 0x36, 0x36, 0x00, 0x00], \u0026#39;;\u0026#39;: [0x00, 0x56, 0x36, 0x00, 0x00], \u0026#39;\u0026lt;\u0026#39;: [0x08, 0x14, 0x22, 0x41, 0x00], \u0026#39;=\u0026#39;: [0x14, 0x14, 0x14, 0x14, 0x14], \u0026#39;\u0026gt;\u0026#39;: [0x00, 0x41, 0x22, 0x14, 0x08], \u0026#39;?\u0026#39;: [0x02, 0x01, 0x51, 0x09, 0x06], \u0026#39;@\u0026#39;: [0x32, 0x49, 0x79, 0x41, 0x3e], \u0026#39;A\u0026#39;: [0x7e, 0x11, 0x11, 0x11, 0x7e], \u0026#39;B\u0026#39;: [0x7f, 0x49, 0x49, 0x49, 0x36], \u0026#39;C\u0026#39;: [0x3e, 0x41, 0x41, 0x41, 0x22], \u0026#39;D\u0026#39;: [0x7f, 0x41, 0x41, 0x22, 0x1c], \u0026#39;E\u0026#39;: [0x7f, 0x49, 0x49, 0x49, 0x41], \u0026#39;F\u0026#39;: [0x7f, 0x09, 0x09, 0x09, 0x01], \u0026#39;G\u0026#39;: [0x3e, 0x41, 0x49, 0x49, 0x7a], \u0026#39;H\u0026#39;: [0x7f, 0x08, 0x08, 0x08, 0x7f], \u0026#39;I\u0026#39;: [0x00, 0x41, 0x7f, 0x41, 0x00], \u0026#39;J\u0026#39;: [0x20, 0x40, 0x41, 0x3f, 0x01], \u0026#39;K\u0026#39;: [0x7f, 0x08, 0x14, 0x22, 0x41], \u0026#39;L\u0026#39;: [0x7f, 0x40, 0x40, 0x40, 0x40], \u0026#39;M\u0026#39;: [0x7f, 0x02, 0x0c, 0x02, 0x7f], \u0026#39;N\u0026#39;: [0x7f, 0x04, 0x08, 0x10, 0x7f], \u0026#39;O\u0026#39;: [0x3e, 0x41, 0x41, 0x41, 0x3e], \u0026#39;P\u0026#39;: [0x7f, 0x09, 0x09, 0x09, 0x06], \u0026#39;Q\u0026#39;: [0x3e, 0x41, 0x51, 0x21, 0x5e], \u0026#39;R\u0026#39;: [0x7f, 0x09, 0x19, 0x29, 0x46], \u0026#39;S\u0026#39;: [0x46, 0x49, 0x49, 0x49, 0x31], \u0026#39;T\u0026#39;: [0x01, 0x01, 0x7f, 0x01, 0x01], \u0026#39;U\u0026#39;: [0x3f, 0x40, 0x40, 0x40, 0x3f], \u0026#39;V\u0026#39;: [0x1f, 0x20, 0x40, 0x20, 0x1f], \u0026#39;W\u0026#39;: [0x3f, 0x40, 0x38, 0x40, 0x3f], \u0026#39;X\u0026#39;: [0x63, 0x14, 0x08, 0x14, 0x63], \u0026#39;Y\u0026#39;: [0x07, 0x08, 0x70, 0x08, 0x07], \u0026#39;Z\u0026#39;: [0x61, 0x51, 0x49, 0x45, 0x43], \u0026#39;[\u0026#39;: [0x00, 0x7f, 0x41, 0x41, 0x00], \u0026#39;\\\\\u0026#39;: [0x02, 0x04, 0x08, 0x10, 0x20], \u0026#39;]\u0026#39;: [0x00, 0x41, 0x41, 0x7f, 0x00], \u0026#39;^\u0026#39;: [0x04, 0x02, 0x01, 0x02, 0x04], \u0026#39;_\u0026#39;: [0x40, 0x40, 0x40, 0x40, 0x40], \u0026#39;`\u0026#39;: [0x00, 0x01, 0x02, 0x04, 0x00], \u0026#39;a\u0026#39;: [0x20, 0x54, 0x54, 0x54, 0x78], \u0026#39;b\u0026#39;: [0x7f, 0x48, 0x44, 0x44, 0x38], \u0026#39;c\u0026#39;: [0x38, 0x44, 0x44, 0x44, 0x20], \u0026#39;d\u0026#39;: [0x38, 0x44, 0x44, 0x48, 0x7f], \u0026#39;e\u0026#39;: [0x38, 0x54, 0x54, 0x54, 0x18], \u0026#39;f\u0026#39;: [0x08, 0x7e, 0x09, 0x01, 0x02], \u0026#39;g\u0026#39;: [0x0c, 0x52, 0x52, 0x52, 0x3e], \u0026#39;h\u0026#39;: [0x7f, 0x08, 0x04, 0x04, 0x78], \u0026#39;i\u0026#39;: [0x00, 0x44, 0x7d, 0x40, 0x00], \u0026#39;j\u0026#39;: [0x20, 0x40, 0x44, 0x3d, 0x00], \u0026#39;k\u0026#39;: [0x7f, 0x10, 0x28, 0x44, 0x00], \u0026#39;l\u0026#39;: [0x00, 0x41, 0x7f, 0x40, 0x00], \u0026#39;m\u0026#39;: [0x7c, 0x04, 0x18, 0x04, 0x78], \u0026#39;n\u0026#39;: [0x7c, 0x08, 0x04, 0x04, 0x78], \u0026#39;o\u0026#39;: [0x38, 0x44, 0x44, 0x44, 0x38], \u0026#39;p\u0026#39;: [0x7c, 0x14, 0x14, 0x14, 0x08], \u0026#39;q\u0026#39;: [0x08, 0x14, 0x14, 0x18, 0x7c], \u0026#39;r\u0026#39;: [0x7c, 0x08, 0x04, 0x04, 0x08], \u0026#39;s\u0026#39;: [0x48, 0x54, 0x54, 0x54, 0x20], \u0026#39;t\u0026#39;: [0x04, 0x3f, 0x44, 0x40, 0x20], \u0026#39;u\u0026#39;: [0x3c, 0x40, 0x40, 0x20, 0x7c], \u0026#39;v\u0026#39;: [0x1c, 0x20, 0x40, 0x20, 0x1c], \u0026#39;w\u0026#39;: [0x3c, 0x40, 0x30, 0x40, 0x3c], \u0026#39;x\u0026#39;: [0x44, 0x28, 0x10, 0x28, 0x44], \u0026#39;y\u0026#39;: [0x0c, 0x50, 0x50, 0x50, 0x3c], \u0026#39;z\u0026#39;: [0x44, 0x64, 0x54, 0x4c, 0x44], \u0026#39;{\u0026#39;: [0x00, 0x08, 0x36, 0x41, 0x00], \u0026#39;|\u0026#39;: [0x00, 0x00, 0x7f, 0x00, 0x00], \u0026#39;}\u0026#39;: [0x00, 0x41, 0x36, 0x08, 0x00], \u0026#39;~\u0026#39;: [0x10, 0x08, 0x08, 0x10, 0x08], \u0026#39;\\x7f\u0026#39;: [0x00, 0x7e, 0x42, 0x42, 0x7e], } X = 13 Y = 5 class PCD8544(object): \u0026#34;\u0026#34;\u0026#34;Nokia 5110/3310 PCD8544-based LCD display.\u0026#34;\u0026#34;\u0026#34; def __init__(self, dc, rst, sclk=None, din=None, cs=None, gpio=None, spi=None, vcc=None, bl=None): self._sclk = sclk self._din = din self._dc = dc self._cs = cs self._rst = rst self._gpio = gpio self._spi = spi self._buffer = [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC0, 0xE0, 0xF0, 0xF8, 0xFC, 0xFC, 0xFE, 0xFF, 0xFC, 0xE0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF8, 0xF8, 0xF8, 0xF8, 0xF8, 0xF8, 0xF8, 0xF8, 0xF8, 0xF8, 0xF8, 0xF8, 0xF0, 0xF0, 0xE0, 0xE0, 0xC0, 0x80, 0xC0, 0xFC, 0xFF, 0xFF, 0xFF, 0xFF, 0x7F, 0x3F, 0x7F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0F, 0x1F, 0x3F, 0x7F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xE7, 0xC7, 0xC7, 0x87, 0x8F, 0x9F, 0x9F, 0xFF, 0xFF, 0xFF, 0xC1, 0xC0, 0xE0, 0xFC, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFC, 0xFC, 0xFC, 0xFC, 0xFE, 0xFE, 0xFE, 0xFC, 0xFC, 0xF8, 0xF8, 0xF0, 0xE0, 0xC0, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0xC0, 0xE0, 0xF1, 0xFB, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x7F, 0x1F, 0x0F, 0x0F, 0x87, 0xE7, 0xFF, 0xFF, 0xFF, 0x1F, 0x1F, 0x3F, 0xF9, 0xF8, 0xF8, 0xF8, 0xF8, 0xF8, 0xF8, 0xFD, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x7F, 0x3F, 0x0F, 0x07, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF0, 0xFE, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFE, 0x7E, 0x3F, 0x3F, 0x0F, 0x1F, 0xFF, 0xFF, 0xFF, 0xFC, 0xF0, 0xE0, 0xF1, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFC, 0xF0, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x01, 0x01, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x0F, 0x1F, 0x3F, 0x7F, 0x7F, 0xFF, 0xFF, 0xFF, 0xFF, 0x7F, 0x7F, 0x1F, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 ] if self._gpio is None: self._gpio = GPIO.get_platform_gpio() self._gpio.setup(vcc, GPIO.OUT) self._gpio.setup(bl, GPIO.OUT) self._gpio.output(vcc, 1) self._gpio.output(bl, 1) if self._rst is not None: self._gpio.setup(self._rst, GPIO.OUT) # Default to bit bang SPI. if self._spi is None: self._spi = SPI.BitBang(self._gpio, self._sclk, self._din, None, self._cs) # Set pin outputs. self._gpio.setup(self._dc, GPIO.OUT) # Initialize buffer to Adafruit logo. def command(self, c): \u0026#34;\u0026#34;\u0026#34;Send command byte to display.\u0026#34;\u0026#34;\u0026#34; # DC pin low signals command byte. self._gpio.set_low(self._dc) self._spi.write([c]) def extended_command(self, c): \u0026#34;\u0026#34;\u0026#34;Send a command in extended mode\u0026#34;\u0026#34;\u0026#34; # Set extended command mode self.command(PCD8544_FUNCTIONSET | PCD8544_EXTENDEDINSTRUCTION) self.command(c) # Set normal display mode. self.command(PCD8544_FUNCTIONSET) self.command(PCD8544_DISPLAYCONTROL | PCD8544_DISPLAYNORMAL) def begin(self, contrast=40, bias=4): \u0026#34;\u0026#34;\u0026#34;Initialize display.\u0026#34;\u0026#34;\u0026#34; self.reset() # Set LCD bias. self.set_bias(bias) self.set_contrast(contrast) def reset(self): \u0026#34;\u0026#34;\u0026#34;Reset the display\u0026#34;\u0026#34;\u0026#34; if self._rst is not None: # Toggle RST low to reset. self._gpio.set_low(self._rst) time.sleep(0.1) self._gpio.set_high(self._rst) def display(self): \u0026#34;\u0026#34;\u0026#34;Write display buffer to physical display.\u0026#34;\u0026#34;\u0026#34; # TODO: Consider support for partial updates like Arduino library. # Reset to position zero. self.command(PCD8544_SETYADDR) self.command(PCD8544_SETXADDR) # Write the buffer. self._gpio.set_high(self._dc) self._spi.write(self._buffer) def clear(self): \u0026#34;\u0026#34;\u0026#34;Clear contents of image buffer.\u0026#34;\u0026#34;\u0026#34; self._buffer = [0] * (LCDWIDTH * LCDHEIGHT // 8) def set_contrast(self, contrast): \u0026#34;\u0026#34;\u0026#34;Set contrast to specified value (should be 0-127).\u0026#34;\u0026#34;\u0026#34; contrast = max(0, min(contrast, 0x7f)) # Clamp to values 0-0x7f self.extended_command(PCD8544_SETVOP | contrast) def set_bias(self, bias): \u0026#34;\u0026#34;\u0026#34;Set bias\u0026#34;\u0026#34;\u0026#34; self.extended_command(PCD8544_SETBIAS | bias) def draw_str(self, y, s): \u0026#34;\u0026#34;\u0026#34;修改显示数据，y 为第几行，s 为要显示的数据\u0026#34;\u0026#34;\u0026#34; if (y \u0026gt;= Y ) or (y \u0026lt; 0): return False x = 0 for c in s[0:14]: try: self._buffer[y*84+x*6: y*84+x*6 + 6] = FONT[c] + [0] except KeyError: pass x += 1 def draw_char(self, x, y): pass def quit(self): self._gpio.cleanup()   接线(BCM)  dc 13 rst 5 sclk 26 din 19 cs 6 vcc 20 bl 21 gnd 0v  显示信息 网速 显示路由器的网速，电脑网速就没必要了 我用的是老毛子固件,所以用这个固件的可以参考我的代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111  # coding:utf-8 import requests import time from math import fabs from base64 import b64encode # from demjson import decode class RaspberryMonitorNetSpeed: url = \u0026#39;http://192.168.123.1/update.cgi?output=netdev\u0026#39; headers = { \u0026#39;Accept\u0026#39;: \u0026#39;text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8\u0026#39;, \u0026#39;Accept-Encoding\u0026#39;: \u0026#39;gzip, deflate\u0026#39;, \u0026#39;Accept-Language\u0026#39;: \u0026#39;zh-CN,zh;q=0.9,en;q=0.8\u0026#39;, \u0026#39;Cache-Control\u0026#39;: \u0026#39;max-age=0\u0026#39;, # \u0026#39;Connection\u0026#39;:\u0026#39;keep-alive\u0026#39;, \u0026#39;Connection\u0026#39;: \u0026#39;close\u0026#39;, \u0026#39;Cookie\u0026#39;: \u0026#39;n56u_cookie_bw_rt_tab=WAN\u0026#39;, \u0026#39;Host\u0026#39;: \u0026#39;192.168.123.1\u0026#39;, \u0026#39;Upgrade-Insecure-Requests\u0026#39;: \u0026#39;1\u0026#39;, \u0026#39;User-Agent\u0026#39;: \u0026#39;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/64.0.3282.186 Safari/537.36\u0026#39;, } # 最近一次请求时间 last_time = 0 # 最近一次请求的下行数据总量 last_rbytes = 0 # 最近一次请求的上行数据总量 last_tbytes = 0 def __init__(self, username, passwd): self.headers[\u0026#39;Authorization\u0026#39;] = \u0026#39;Basic \u0026#39;+b64encode((username+\u0026#39;:\u0026#39;+passwd).encode()).decode() data = self.__get_wan_rx_and_tx() self.last_rbytes = data[0] self.last_tbytes = data[1] self.last_time = data[2] def set_auth(self, username, passwd): self.headers[\u0026#39;Authorization\u0026#39;] = \u0026#39;Basic \u0026#39;+b64encode((username+\u0026#39;:\u0026#39;+passwd).encode()).decode() def __get_wan_rx_and_tx(self): text = requests.get(self.url, headers=self.headers).text try: rx = int(text.split(\u0026#39;,\u0026#39;)[25].lstrip(\u0026#39;rx:\u0026#39;).strip(), 16) tx = int(text.split(\u0026#39;,\u0026#39;)[26].lstrip(\u0026#39;tx:\u0026#39;).rstrip(\u0026#39;}\\n\u0026#39;).strip(), 16) new_time = time.time() except (IndexError, ValueError, TypeError): return False return [rx, tx, new_time] def get_human_speed(self): \u0026#34;\u0026#34;\u0026#34;这里返回的是 M/s 这种网速，[下载，上传]\u0026#34;\u0026#34;\u0026#34; data = self.__get_wan_rx_and_tx() if data: down_speed = 0 up_speed = 0 try: down_speed = self.__bytes_to_humanspeed((data[0] - self.last_rbytes) / (data[2] - self.last_time)) up_speed = self.__bytes_to_humanspeed((data[1] - self.last_tbytes) / (data[2] - self.last_time)) except ZeroDivisionError: pass self.last_rbytes = data[0] self.last_tbytes = data[1] self.last_time = data[2] return down_speed, up_speed def __bytes_to_humanspeed(self, B): absval = fabs(B) / 1024 megabyte = 1024 gigabyte = megabyte * 1024 terabyte = gigabyte * 1024 # petabyte = terabyte * 1024 if absval \u0026lt; megabyte: return str(round(absval, 2)) + \u0026#39; KB/s\u0026#39; elif absval \u0026lt; gigabyte: return str(round(absval / megabyte, 2)) + \u0026#39; M/s\u0026#39; else: return str(round(absval / gigabyte, 2)) + \u0026#39; G/s\u0026#39; def get_bits_speed(self): \u0026#34;\u0026#34;\u0026#34;这里返回的是 Mbps 这种网速，[下载，上传]\u0026#34;\u0026#34;\u0026#34; data = self.__get_wan_rx_and_tx() if data: down_speed = self.__bytes_to_bitrate((data[0] - self.last_rbytes) / (data[2] - self.last_time)) up_speed = self.__bytes_to_bitrate((data[1] - self.last_tbytes) / (data[2] - self.last_time)) self.last_rbytes = data[0] self.last_tbytes = data[1] self.last_time = data[2] return down_speed, up_speed def __bytes_to_bitrate(self, B): bits = B * 8 absval = fabs(bits) kilobit = 1000 megabit = kilobit * 1000 gigabit = megabit * 1000 if absval \u0026lt; megabit: return str(round(bits / kilobit, 2)) + \u0026#39; Kbps\u0026#39; elif absval \u0026lt; gigabit: return str(round(bits / megabit, 2)) + \u0026#39; Mbps\u0026#39; else: return str(round(bits / gigabit, 2)) + \u0026#39; Gbps\u0026#39; if __name__ == \u0026#39;__main__\u0026#39;: from lcd1602 import LCD1602 a = RaspberryMonitorNetSpeed(\u0026#39;username\u0026#39;, \u0026#39;password\u0026#39;) lcd = LCD1602() while True: tmp = a.get_human_speed() lcd.lcd_string(\u0026#39;u:\u0026#39; + tmp[1], lcd.LCD_LINE_1) lcd.lcd_string(\u0026#39;d:\u0026#39; + tmp[0], lcd.LCD_LINE_2) time.sleep(2)   温度 这里用的是 DTH11，驱动同样参考这个(Adafruit)\n开始显示 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55  import time import datetime from PCD8544 import PCD8544 as lcd import threading import Adafruit_DHT from speed import RaspberryMonitorNetSpeed as rmn ns = [-1, -1] th = [-2, -2] def main(): a = lcd(dc=13, rst=5, sclk=26, din=19, cs=6, vcc=20, bl=21) a.begin(contrast=60) tmp = threading.Thread(target=network_speed) tmp.setDaemon(True) tmp.start() tmp = threading.Thread(target=temperature_humidity) tmp.setDaemon(True) tmp.start() while True: try: a.clear() # 上传速度 a.draw_str(0, \u0026#39;U: \u0026#39; + str(ns[1])) # 下载速度 a.draw_str(1, \u0026#39;D: \u0026#39; + str(ns[0])) # 温度 a.draw_str(2, \u0026#39;T: \u0026#39; + str(th[1]) + \u0026#39; C\u0026#39;) # 湿度 a.draw_str(3, \u0026#39;H: \u0026#39; + str(th[0]) + \u0026#39;%\u0026#39;) # 时间 a.draw_str(4, datetime.datetime.now().__str__()[5:].lstrip(\u0026#39;0\u0026#39;).split(\u0026#39;.\u0026#39;)[0]) a.display() time.sleep(1) except KeyboardInterrupt: a.quit() exit(0) def network_speed(): global ns b = rmn(\u0026#39;bankroft\u0026#39;, \u0026#39;123456\u0026#39;) while True: time.sleep(1) ns = b.get_human_speed() def temperature_humidity(): global th pin = 25 while True: time.sleep(10) th = Adafruit_DHT.read_retry(11, 25) if __name__ == \u0026#39;__main__\u0026#39;: main()   运行 依赖 python3\n安装 Adafruit_GPIO Adafruit_DHT requests\n运行 python main.py\n成果 ","date":"2019-08-01T12:48:47Z","image":"https://bankroft.github.io/images/posts/raspberry_nokia_5110/2533443824.jpg","permalink":"https://bankroft.github.io/posts/raspberry_nokia_5110/","title":"树莓派使用Nokia 5110屏幕显示网速温度等"},{"content":"code:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113  import RPi.GPIO as GPIO from random import sample import string import time class LCD1602: # Define GPIO to LCD mapping LCD_RS = 14 LCD_E = 15 LCD_D4 = 17 LCD_D5 = 18 LCD_D6 = 27 LCD_D7 = 22 # Define some device constants LCD_WIDTH = 16 # Maximum characters per line LCD_CHR = True LCD_CMD = False LCD_LINE_1 = 0x80 # LCD RAM address for the 1st line LCD_LINE_2 = 0xC0 # LCD RAM address for the 2nd line # Timing constants E_PULSE = 0.0005 E_DELAY = 0.0005 def __init__(self): # Main program block GPIO.setwarnings(False) GPIO.setmode(GPIO.BCM) # Use BCM GPIO numbers GPIO.setup(self.LCD_E, GPIO.OUT) # E GPIO.setup(self.LCD_RS, GPIO.OUT) # RS GPIO.setup(self.LCD_D4, GPIO.OUT) # DB4 GPIO.setup(self.LCD_D5, GPIO.OUT) # DB5 GPIO.setup(self.LCD_D6, GPIO.OUT) # DB6 GPIO.setup(self.LCD_D7, GPIO.OUT) # DB7 # Initialise display self.lcd_init() def lcd_init(self): # Initialise display self.lcd_byte(0x33, self.LCD_CMD) # 110011 Initialise self.lcd_byte(0x32, self.LCD_CMD) # 110010 Initialise self.lcd_byte(0x06, self.LCD_CMD) # 000110 Cursor move direction self.lcd_byte(0x0C, self.LCD_CMD) # 001100 Display On,Cursor Off, Blink Off self.lcd_byte(0x28, self.LCD_CMD) # 101000 Data length, number of lines, font size self.lcd_byte(0x01, self.LCD_CMD) # 000001 Clear display time.sleep(self.E_DELAY) def lcd_byte(self, bits, mode): # Send byte to data pins # bits = data # mode = True for character # False for command GPIO.output(self.LCD_RS, mode) # RS # High bits GPIO.output(self.LCD_D4, False) GPIO.output(self.LCD_D5, False) GPIO.output(self.LCD_D6, False) GPIO.output(self.LCD_D7, False) if bits \u0026amp; 0x10 == 0x10: GPIO.output(self.LCD_D4, True) if bits \u0026amp; 0x20 == 0x20: GPIO.output(self.LCD_D5, True) if bits \u0026amp; 0x40 == 0x40: GPIO.output(self.LCD_D6, True) if bits \u0026amp; 0x80 == 0x80: GPIO.output(self.LCD_D7, True) # Toggle \u0026#39;Enable\u0026#39; pin self.lcd_toggle_enable() # Low bits GPIO.output(self.LCD_D4, False) GPIO.output(self.LCD_D5, False) GPIO.output(self.LCD_D6, False) GPIO.output(self.LCD_D7, False) if bits \u0026amp; 0x01 == 0x01: GPIO.output(self.LCD_D4, True) if bits \u0026amp; 0x02 == 0x02: GPIO.output(self.LCD_D5, True) if bits \u0026amp; 0x04 == 0x04: GPIO.output(self.LCD_D6, True) if bits \u0026amp; 0x08 == 0x08: GPIO.output(self.LCD_D7, True) # Toggle \u0026#39;Enable\u0026#39; pin self.lcd_toggle_enable() def lcd_toggle_enable(self): # Toggle enable time.sleep(self.E_DELAY) GPIO.output(self.LCD_E, True) time.sleep(self.E_PULSE) GPIO.output(self.LCD_E, False) time.sleep(self.E_DELAY) def lcd_string(self, message, line): # Send string to display message = message.ljust(self.LCD_WIDTH, \u0026#34; \u0026#34;) self.lcd_byte(line, self.LCD_CMD) for i in range(self.LCD_WIDTH): self.lcd_byte(ord(message[i]), self.LCD_CHR) if __name__ == \u0026#39;__main__\u0026#39;: a = LCD1602() while True: a.lcd_string(\u0026#39;\u0026#39;.join(sample(string.ascii_letters, k=8)), a.LCD_LINE_1) a.lcd_string(\u0026#39;\u0026#39;.join(sample(string.ascii_letters, k=8)), a.LCD_LINE_2) time.sleep(3)   参考代码\n","date":"2019-08-01T12:46:15Z","permalink":"https://bankroft.github.io/posts/raspberry-pi-3-%E4%BD%BF%E7%94%A8lcd1602/","title":"raspberry pi 3 使用lcd1602"},{"content":" curses urwid   npyscreen Prompt Toolkit curtsies ","date":"2019-08-01T12:21:46Z","permalink":"https://bankroft.github.io/posts/python-terminal-ui/","title":"python terminal ui"},{"content":"代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157  # coding:utf-8 import math def encryptionVirginia(plaintext, secret_key): \u0026#39;\u0026#39;\u0026#39;加密\u0026#39;\u0026#39;\u0026#39; table = [chr(x) for x in range(ord(\u0026#39;a\u0026#39;), ord(\u0026#39;z\u0026#39;) + 1)] tmp = \u0026#39;\u0026#39; for x in plaintext: if x.lower() in table: tmp += x.lower() ciphertext = \u0026#39;\u0026#39; for index, value in enumerate(tmp): t = (table.index(value) + table.index(secret_key[index % len(secret_key)])) % 26 ciphertext += table[t] return ciphertext def decryptionVirginia(ciphertext, secret_key): \u0026#39;\u0026#39;\u0026#39;解密\u0026#39;\u0026#39;\u0026#39; ciphertext = ciphertext.lower() table = [chr(x) for x in range(ord(\u0026#39;a\u0026#39;), ord(\u0026#39;z\u0026#39;) + 1)] plaintext = \u0026#39;\u0026#39; num = 0 for index, value in enumerate(ciphertext): plaintext += table[(table.index(value) - table.index(secret_key[index % len(secret_key)])) % 26] num += 1 return plaintext class CrackVirginia: \u0026#39;\u0026#39;\u0026#39;破解\u0026#39;\u0026#39;\u0026#39; # 字母概率，从a到z LETTER_PROBILITY = { \u0026#39;a\u0026#39;:0.08167, # a \u0026#39;b\u0026#39;:0.01492, # b \u0026#39;c\u0026#39;:0.02782, # c \u0026#39;d\u0026#39;:0.04253, # d \u0026#39;e\u0026#39;:0.12702, # e \u0026#39;f\u0026#39;:0.02228, # f \u0026#39;g\u0026#39;:0.02015, # g \u0026#39;h\u0026#39;:0.06094, # h \u0026#39;i\u0026#39;:0.06966, # i \u0026#39;j\u0026#39;:0.00153, # j \u0026#39;k\u0026#39;:0.00772, # k \u0026#39;l\u0026#39;:0.04025, # l \u0026#39;m\u0026#39;:0.02406, # m \u0026#39;n\u0026#39;:0.06749, # n \u0026#39;o\u0026#39;:0.07507, # o \u0026#39;p\u0026#39;:0.01929, # p \u0026#39;q\u0026#39;:0.00095, # q \u0026#39;r\u0026#39;:0.05897, # r \u0026#39;s\u0026#39;:0.06327, # s \u0026#39;t\u0026#39;:0.09056, # t \u0026#39;u\u0026#39;:0.02758, # u \u0026#39;v\u0026#39;:0.00978, # v \u0026#39;w\u0026#39;:0.02360, # w \u0026#39;x\u0026#39;:0.00150, # x \u0026#39;y\u0026#39;:0.01974, # y \u0026#39;z\u0026#39;:0.00074, # z } def __getSubstring(self, key_length): \u0026#39;\u0026#39;\u0026#39;分割为子串\u0026#39;\u0026#39;\u0026#39; num = 0 while num \u0026lt; key_length: yield self.ciphertext[num::key_length].upper() num += 1 def __fangcha(self, average, li): \u0026#39;\u0026#39;\u0026#39;方差计算\u0026#39;\u0026#39;\u0026#39; tmp = 0 for x in li: tmp += (x - average) ** 2 return tmp / len(li) def __init__(self, ciphertext): self.ciphertext = ciphertext.upper() def __IC_calculate(self, string_str): \u0026#39;\u0026#39;\u0026#39;无偏估计值计算\u0026#39;\u0026#39;\u0026#39; dict_ = {} for x in string_str: try: dict_[x] += 1 except KeyError: dict_[x] = 1 tmp = 0 for value in dict_.values(): try: tmp += ((value * (value-1)) / (len(string_str) * (len(string_str) - 1))) except ZeroDivisionError: return 1 return tmp def __calculate_Mj(self, text): \u0026#39;\u0026#39;\u0026#39;拟重合指数法\u0026#39;\u0026#39;\u0026#39; Mj = 0 alpha = {} for x in text: try: alpha[x] += 1 except KeyError: alpha[x] = 1 for key, value in alpha.items(): Mj += ((self.LETTER_PROBILITY[key.lower()] * value) / len(text)) return Mj def __getKeyLength(self): \u0026#39;\u0026#39;\u0026#39;破解密钥长度\u0026#39;\u0026#39;\u0026#39; key_length_ic = {} key_length_fangcha = {} key_length = 1 result = {} while key_length \u0026lt; len(self.ciphertext): substring = [] for x in self.__getSubstring(key_length): substring.append(x) key_length += 1 tmp = [] for x in substring: ic = self.__IC_calculate(x) tmp.append(ic) if tmp: key_length_ic[str(key_length-1)] = math.fabs(sum(tmp) / len(tmp) - 0.065) key_length_fangcha[str(key_length-1)] = self.__fangcha(key_length_ic[str(key_length-1)], tmp) for key, value in key_length_ic.items(): result[key] = key_length_fangcha[key] * 4 + value key_length = sorted(result.items(), key=lambda a:a[1])[0][0] return int(key_length) def crack(self): \u0026#39;\u0026#39;\u0026#39;破解\u0026#39;\u0026#39;\u0026#39; key_length = self.__getKeyLength() num = 0 key_ic = [] for x in self.__getSubstring(key_length): for t in range(1, 27): s = \u0026#39;\u0026#39;.join([chr(((ord(l)+t-65) % 26) + 65) for l in x]) try: key_ic[num].append(math.fabs(self.__calculate_Mj(s) - 0.065)) except IndexError: key_ic.append([math.fabs(self.__calculate_Mj(s) - 0.065)]) num += 1 key = \u0026#39;\u0026#39; for value in key_ic: key += chr(ord(\u0026#39;z\u0026#39;) - value.index(min(value))) return key string = \u0026#39;CHREEVOAHMAERATBIAXXWTNXBEEOPHBSBQMQEQERBWRVXUOAKXAOSXXWEAHBWGJMMQMNKGRFVGXWTRZXWIAKLXFPSKAUTEMNDCMGTSXMXBTUIADNGMGPSRELXNJELXVRVPRTULHDNQWTWDTYGBPHXTFALJHASVBFXNGLLCHRZBWELEKMSJIKNBHWRJGNMGJSGLXFEYPHAGNRBIEQJTAMRVLCRREMNDGLXRRIMGNSNRWCHRQHAEYEVTAQEBBIPEEWEVKAKOEWADREMXMTBHHCHRTKDNVRZCHRCLQOHPWQAIIWXNRMGWOIIFKEE\u0026#39; a = CrackVirginia(string) key = a.crack() plaintext = decryptionVirginia(string, a.crack()) print(\u0026#39;明文为:\u0026#39;, plaintext, end=\u0026#39;\\n\\n\u0026#39;) print(\u0026#39;加密密钥:\u0026#39;, key, end=\u0026#39;\\n\\n\u0026#39;) print(\u0026#39;加密后:\u0026#39;, string, end=\u0026#39;\\n\\n\u0026#39;) print(\u0026#39;破解密钥:\u0026#39;, key, end=\u0026#39;\\n\\n\u0026#39;) print(\u0026#39;破解明文:\u0026#39;, plaintext, end=\u0026#39;\\n\\n\u0026#39;)   ","date":"2019-08-01T12:16:06Z","permalink":"https://bankroft.github.io/posts/python3%E5%AE%9E%E7%8E%B0vigenere%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%86%E7%A0%B4%E8%A7%A3/","title":"python3实现Vigenere加密、解密、破解"},{"content":"python3实现AES ECB 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377  # coding:utf-8 import copy import math \u0026#39;\u0026#39;\u0026#39; test_state: 0x3243f6a8, 0x885a308d, 0x313198a2, 0xe0370734 test_cipher key: 0x2b7e1516, 0x28aed2a6, 0xabf71588, 0x09cf4f3c \u0026#39;\u0026#39;\u0026#39; class EncryptionAES: \u0026#39;\u0026#39;\u0026#39; pass \u0026#39;\u0026#39;\u0026#39; key = [] plaintext = [] wheels_number = 10 # 加密轮数 sbox = [ [0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5, 0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76], [0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0, 0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0], [0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc, 0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15], [0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a, 0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75], [0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0, 0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84], [0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b, 0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf], [0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85, 0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8], [0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5, 0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2], [0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17, 0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73], [0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88, 0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb], [0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c, 0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79], [0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9, 0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08], [0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6, 0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a], [0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e, 0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e], [0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94, 0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf], [0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68, 0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16] ] rcon = [ [0x01, 0x00, 0x00, 0x00], [0x02, 0x00, 0x00, 0x00], [0x04, 0x00, 0x00, 0x00], [0x08, 0x00, 0x00, 0x00], [0x10, 0x00, 0x00, 0x00], [0x20, 0x00, 0x00, 0x00], [0x40, 0x00, 0x00, 0x00], [0x80, 0x00, 0x00, 0x00], [0x1b, 0x00, 0x00, 0x00], [0x36, 0x00, 0x00, 0x00] ] def __init__(self, plaintext): self.plaintext = plaintext.encode() for x in range((int(math.fabs((len(self.plaintext) % 16) - 16)))): self.plaintext += \u0026#39;\\x00\u0026#39;.encode() def __get_plaintext(self): t = 0 while t \u0026lt; len(self.plaintext): yield self.plaintext[t:t+16] t += 16 def set_number_of_encrypt_wheels(self, wheels_number): \u0026#39;\u0026#39;\u0026#39; 设置加密轮数，默认10，待定 \u0026#39;\u0026#39;\u0026#39; self.wheels_number = wheels_number def __get_state(self, text): n = [] x = 0 for _ in range(4): l = [] for _ in range(4): l.append(text[x]) x += 1 n.append(l) return n def set_key(self, key): \u0026#39;\u0026#39;\u0026#39; pass \u0026#39;\u0026#39;\u0026#39; key = key.encode() key_length = int(len(key)) len_key = [16, 24] # 密钥长度不正确处理 if key_length not in len_key: return False tmp = 0 for _ in range(int(key_length / 4)): t = [] for _ in range(4): t.append(key[tmp]) tmp += 1 self.key.append(t) for x in range(4, 4 * (self.wheels_number + 1)): if x % 4 == 0: tmp = self.key[x - 1][:] tmp.append(tmp[0]) tmp.pop(0) for y in range(4): tmp[y] = self.__get_sbox_value(tmp[y]) for y in range(4): tmp[y] = self.key[x-4][y] ^ tmp[y] ^ self.rcon[int(x/4) - 1][y] self.key.append(tmp) else: l = [] for y in range(4): l.append(self.key[x - 1][y] ^ self.key[x - 4][y]) self.key.append(l) def __get_sbox_value(self, value): return self.sbox[(value \u0026amp; 0xf0) \u0026gt;\u0026gt; 4][value \u0026amp; 0x0f] def get_ciphertext(self): \u0026#39;\u0026#39;\u0026#39; pass \u0026#39;\u0026#39;\u0026#39; ciphertext = \u0026#39;\u0026#39; for text in self.__get_plaintext(): state = self.__get_state(text) self.__wheel_key_add(state, 0) for x in range(1, self.wheels_number): self.__subbytes(state) state = self.__shift_rows(state) self.__mix_columns(state) self.__wheel_key_add(state, x) self.__subbytes(state) state = self.__shift_rows(state) self.__wheel_key_add(state, self.wheels_number) for x in range(4): for y in range(4): t = hex(state[x][y]).split(\u0026#39;0x\u0026#39;)[-1] if len(t) == 1: ciphertext += \u0026#39;0\u0026#39;+t else: ciphertext += t return ciphertext def __shift_rows(self, state): \u0026#39;\u0026#39;\u0026#39; 行移位 参数state：分组列表 \u0026#39;\u0026#39;\u0026#39; state = list(map(list, zip(*state))) for x in range(1, 4): for y in range(x): state[x].append(state[x][0]) state[x].pop(0) state = list(map(list, zip(*state))) return state def __subbytes(self, state): # 完成 for x in range(4): for y in range(4): state[x][y] = self.__get_sbox_value(state[x][y]) def __mix_columns(self, state): for x in range(4): tmp = state[x][:] state[x][0] = self.__ffmul(0x02, tmp[0]) ^ self.__ffmul(0x03, tmp[1]) ^ tmp[2] ^ tmp[3] state[x][1] = tmp[0] ^ self.__ffmul(0x02, tmp[1]) ^ self.__ffmul(0x03, tmp[2]) ^ tmp[3] state[x][2] = tmp[0] ^ tmp[1] ^ self.__ffmul(0x02, tmp[2]) ^ self.__ffmul(0x03, tmp[3]) state[x][3] = self.__ffmul(0x03, tmp[0]) ^ tmp[1] ^ tmp[2] ^ self.__ffmul(0x02, tmp[3]) def __ffmul(self, x, y): if x == 0x02: if y \u0026gt;= 0x80: return ((y \u0026lt;\u0026lt; 1) ^ 0x0100 ^ 0x1b) else: return (y \u0026lt;\u0026lt; 1) elif x == 0x03: return (self.__ffmul(0x02, y) ^ y) else: return 0x00 def __wheel_key_add(self, state, number): # 完成 for x in range(4): for y in range(4): state[x][y] = state[x][y] ^ self.key[4 * number+x][y] class DecryptionAES: \u0026#39;\u0026#39;\u0026#39; AES-128 ECB 解密（填充\\x00） \u0026#39;\u0026#39;\u0026#39; wheels_number = 10 reverse_sbox = [ [0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38, 0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb], [0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87, 0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb], [0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d, 0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e], [0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2, 0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25], [0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92], [0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda, 0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84], [0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a, 0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06], [0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02, 0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b], [0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea, 0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73], [0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85, 0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e], [0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89, 0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b], [0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20, 0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4], [0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31, 0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f], [0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d, 0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef], [0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0, 0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61], [0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26, 0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d] ] rcon = [ [0x01, 0x00, 0x00, 0x00], [0x02, 0x00, 0x00, 0x00], [0x04, 0x00, 0x00, 0x00], [0x08, 0x00, 0x00, 0x00], [0x10, 0x00, 0x00, 0x00], [0x20, 0x00, 0x00, 0x00], [0x40, 0x00, 0x00, 0x00], [0x80, 0x00, 0x00, 0x00], [0x1b, 0x00, 0x00, 0x00], [0x36, 0x00, 0x00, 0x00] ] sbox = [ [0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5, 0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76], [0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0, 0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0], [0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc, 0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15], [0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a, 0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75], [0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0, 0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84], [0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b, 0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf], [0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85, 0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8], [0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5, 0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2], [0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17, 0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73], [0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88, 0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb], [0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c, 0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79], [0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9, 0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08], [0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6, 0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a], [0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e, 0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e], [0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94, 0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf], [0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68, 0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16] ] key = [] def __init__(self, ciphertext, ciphertext_format): \u0026#39;\u0026#39;\u0026#39; ciphertext_format = [\u0026#39;hex\u0026#39;] \u0026#39;\u0026#39;\u0026#39; self.ciphertext = [] if ciphertext_format == \u0026#39;hex\u0026#39;: t = 0 while t \u0026lt; len(ciphertext): l = [] for x in range(4): l.append(int(ciphertext[t:t+2], 16)) t += 2 self.ciphertext.append(l) def __get_sbox_value(self, value): \u0026#39;\u0026#39;\u0026#39;通过8位二进制返回sbox值\u0026#39;\u0026#39;\u0026#39; return self.sbox[(value \u0026amp; 0xf0) \u0026gt;\u0026gt; 4][value \u0026amp; 0x0f] def __get_ciphertext(self): \u0026#39;\u0026#39;\u0026#39;迭代128位密文\u0026#39;\u0026#39;\u0026#39; for x in range(0, len(self.ciphertext), 4): yield self.ciphertext[x:x+4] def __wheel_key_add(self, state, number): \u0026#39;\u0026#39;\u0026#39;密钥轮加\u0026#39;\u0026#39;\u0026#39; for x in range(4): for y in range(4): state[x][y] = state[x][y] ^ self.key[4 * number+x][y] def __get_state(self, text): n = [] x = 0 for _ in range(4): l = [] for _ in range(4): l.append(text[x]) x += 1 n.append(l) return n def get_plaintext(self): plaintext = \u0026#39;\u0026#39; for text in self.__get_ciphertext(): state = text self.__wheel_key_add(state, self.wheels_number) for x in range(self.wheels_number-1, 0, -1): state = self.__reverse_shift_rows(state) self.__reverse_subbytes(state) self.__wheel_key_add(state, x) self.__reverse_mix_columns(state) state = self.__reverse_shift_rows(state) self.__reverse_subbytes(state) self.__wheel_key_add(state, 0) for x in range(4): for y in range(4): plaintext += chr(state[x][y]) return plaintext.strip(\u0026#39;\\x00\u0026#39;) def __reverse_mix_columns(self, state): for x in range(4): tmp = state[x][:] state[x][0] = (self.__xtime(self.__xtime(self.__xtime(tmp[0]))) ^ self.__xtime(self.__xtime(tmp[0])) ^ self.__xtime(tmp[0])) ^ (self.__xtime(self.__xtime(self.__xtime(tmp[1]))) ^ self.__xtime(tmp[1]) ^ tmp[1]) ^ (self.__xtime(self.__xtime(self.__xtime(tmp[2]))) ^ self.__xtime(self.__xtime(tmp[2])) ^ tmp[2]) ^ (self.__xtime(self.__xtime(self.__xtime(tmp[3]))) ^ tmp[3]) state[x][1] = (self.__xtime(self.__xtime(self.__xtime(tmp[0]))) ^ tmp[0]) ^ (self.__xtime(self.__xtime(self.__xtime(tmp[1]))) ^ self.__xtime(self.__xtime(tmp[1])) ^ self.__xtime(tmp[1])) ^ (self.__xtime(self.__xtime(self.__xtime(tmp[2]))) ^ self.__xtime(tmp[2]) ^ tmp[2]) ^ (self.__xtime(self.__xtime(self.__xtime(tmp[3]))) ^ self.__xtime(self.__xtime(tmp[3])) ^ tmp[3]) state[x][2] = (self.__xtime(self.__xtime(self.__xtime(tmp[0]))) ^ self.__xtime(self.__xtime(tmp[0])) ^ tmp[0]) ^ (self.__xtime(self.__xtime(self.__xtime(tmp[1]))) ^ tmp[1]) ^ (self.__xtime(self.__xtime(self.__xtime(tmp[2]))) ^self.__xtime(self.__xtime(tmp[2])) ^ self.__xtime(tmp[2])) ^ (self.__xtime(self.__xtime(self.__xtime(tmp[3]))) ^ self.__xtime(tmp[3]) ^ tmp[3]) state[x][3] = (self.__xtime(self.__xtime(self.__xtime(tmp[0]))) ^ self.__xtime(tmp[0]) ^ tmp[0]) ^ (self.__xtime(self.__xtime(self.__xtime(tmp[1]))) ^ self.__xtime(self.__xtime(tmp[1])) ^ tmp[1]) ^ (self.__xtime(self.__xtime(self.__xtime(tmp[2]))) ^ tmp[2]) ^ (self.__xtime(self.__xtime(self.__xtime(tmp[3]))) ^ self.__xtime(self.__xtime(tmp[3])) ^ self.__xtime(tmp[3])) def __xtime(self, x): if x \u0026gt;= 0x80: return ((x \u0026lt;\u0026lt; 1) ^ 0x0100 ^ 0x1b) else: return (x \u0026lt;\u0026lt; 1) def __reverse_subbytes(self, state): for x in range(4): for y in range(4): state[x][y] = self.__get_reversesbox_value(state[x][y]) def __reverse_shift_rows(self, state): \u0026#39;\u0026#39;\u0026#39; \u0026#39;\u0026#39;\u0026#39; state = list(map(list, zip(*state))) for x in range(1, 4): for y in range(x): state[x].insert(0, state[x][-1]) state[x].pop() state = list(map(list, zip(*state))) return state def set_key(self, key): \u0026#39;\u0026#39;\u0026#39; 设置密钥，扩展密钥, 长度规定为128(， 192， 256) key:密钥 \u0026#39;\u0026#39;\u0026#39; key = key.encode() key_length = int(len(key)) # len_key = [16, 24, 32] len_key = [16] # 密钥长度不正确处理 if key_length not in len_key: return False tmp = 0 for _ in range(int(key_length / 4)): t = [] for _ in range(4): t.append(key[tmp]) tmp += 1 self.key.append(t) for x in range(4, 4 * (self.wheels_number + 1)): if x % 4 == 0: tmp = self.key[x - 1][:] tmp.append(tmp[0]) tmp.pop(0) for y in range(4): tmp[y] = self.__get_sbox_value(tmp[y]) for y in range(4): tmp[y] = self.key[x-4][y] ^ tmp[y] ^ self.rcon[int(x/4) - 1][y] self.key.append(tmp) else: l = [] for y in range(4): l.append(self.key[x - 1][y] ^ self.key[x - 4][y]) self.key.append(l) def __get_reversesbox_value(self, value): \u0026#39;\u0026#39;\u0026#39; 通过8位二进制返回逆sbox值 \u0026#39;\u0026#39;\u0026#39; return self.reverse_sbox[(value \u0026amp; 0xf0) \u0026gt;\u0026gt; 4][value \u0026amp; 0x0f] key = \u0026#39;abcdefghijklmnop\u0026#39; string = \u0026#39;eriltugvnaiosjevtgoaeujfcvmoqaj4otyivu00\u0026#39; print(\u0026#39;明文字符串:\u0026#39;, string) print(\u0026#39;密钥:\u0026#39;, key) a = EncryptionAES(string) a.set_key(key) print(\u0026#39;加密结果:\u0026#39;, a.get_ciphertext()) a.get_ciphertext() a = DecryptionAES(a.get_ciphertext(), \u0026#39;hex\u0026#39;) a.set_key(key) print(\u0026#39;解密结果: \u0026#39;, a.get_plaintext())   ","date":"2019-08-01T12:02:05Z","permalink":"https://bankroft.github.io/posts/python3-6%E5%AE%9E%E7%8E%B0aes-ecb/","title":"Python3.6实现AES(ECB)"}]